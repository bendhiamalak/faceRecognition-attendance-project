<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/database.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/database.py" />
              <option name="originalContent" value="import sqlite3&#10;from datetime import datetime&#10;import pickle&#10;&#10;class AttendanceDatabase:&#10;    def __init__(self, db_name='attendance_system.db'):&#10;        self.db_name = db_name&#10;        self.init_database()&#10;    &#10;    def init_database(self):&#10;        &quot;&quot;&quot;Initialise la base de données avec les tables nécessaires&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        &#10;        # Table des professeurs&#10;        c.execute('''CREATE TABLE IF NOT EXISTS professors (&#10;            id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;            first_name TEXT NOT NULL,&#10;            last_name TEXT NOT NULL,&#10;            subject TEXT NOT NULL,&#10;            email TEXT NOT NULL UNIQUE,&#10;            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;        )''')&#10;        &#10;        # Table des étudiants&#10;        c.execute('''CREATE TABLE IF NOT EXISTS students (&#10;            id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;            first_name TEXT NOT NULL,&#10;            last_name TEXT NOT NULL,&#10;            photo_path TEXT,&#10;            encoding BLOB,&#10;            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;        )''')&#10;        &#10;        # Table des séances&#10;        c.execute('''CREATE TABLE IF NOT EXISTS sessions (&#10;            id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;            professor_id INTEGER,&#10;            subject TEXT,&#10;            session_date DATE,&#10;            start_time TIME,&#10;            end_time TIME,&#10;            FOREIGN KEY (professor_id) REFERENCES professors(id)&#10;        )''')&#10;        &#10;        # Table des présences&#10;        c.execute('''CREATE TABLE IF NOT EXISTS attendance (&#10;            id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;            session_id INTEGER,&#10;            student_id INTEGER,&#10;            check_in_time TIMESTAMP,&#10;            status TEXT DEFAULT 'present',&#10;            FOREIGN KEY (session_id) REFERENCES sessions(id),&#10;            FOREIGN KEY (student_id) REFERENCES students(id),&#10;            UNIQUE(session_id, student_id)&#10;        )''')&#10;        &#10;        # Assurer l'existence de la colonne email et d'un index UNIQUE (migration pour bases existantes)&#10;        c.execute(&quot;PRAGMA table_info('professors')&quot;)&#10;        cols = [row[1] for row in c.fetchall()]&#10;        if 'email' not in cols:&#10;            try:&#10;                c.execute(&quot;ALTER TABLE professors ADD COLUMN email TEXT&quot;)&#10;                conn.commit()&#10;                print(&quot;→ Colonne 'email' ajoutée à la table professors (migration)&quot;)&#10;            except Exception as e:&#10;                print(f&quot;⚠ Impossible d'ajouter la colonne 'email': {e}&quot;)&#10;        # Créer un index UNIQUE si non présent (permet d'imposer l'unicité sur les valeurs non-null)&#10;        try:&#10;            c.execute(&quot;CREATE UNIQUE INDEX IF NOT EXISTS idx_professors_email ON professors(email);&quot;)&#10;            conn.commit()&#10;        except Exception as e:&#10;            print(f&quot;⚠ Impossible de créer l'index unique sur email: {e}&quot;)&#10;        &#10;        conn.close()&#10;        print(&quot;✓ Base de données initialisée avec succès&quot;)&#10;    &#10;    # === GESTION PROFESSEURS ===&#10;    def add_professor(self, first_name, last_name, subject, email):&#10;        &quot;&quot;&quot;Ajoute un professeur&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        try:&#10;            c.execute('''INSERT INTO professors (first_name, last_name, subject, email)&#10;                        VALUES (?, ?, ?, ?)''', (first_name, last_name, subject, email))&#10;            conn.commit()&#10;            professor_id = c.lastrowid&#10;            print(f&quot;✓ Professeur {first_name} {last_name} ajouté avec ID: {professor_id}&quot;)&#10;            return professor_id&#10;        except sqlite3.IntegrityError as ie:&#10;            # Erreur d'unicité (email déjà existant)&#10;            print(f&quot;✗ Intégrité DB lors de l'ajout du professeur (possible email dupliqué): {ie}&quot;)&#10;            return None&#10;        except Exception as e:&#10;            print(f&quot;✗ Erreur lors de l'ajout du professeur: {e}&quot;)&#10;            return None&#10;        finally:&#10;            conn.close()&#10;    &#10;    def get_all_professors(self):&#10;        &quot;&quot;&quot;Récupère tous les professeurs&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        c.execute('SELECT * FROM professors ORDER BY last_name')&#10;        professors = c.fetchall()&#10;        conn.close()&#10;        return professors&#10;&#10;    def get_professor_by_email(self, email):&#10;        &quot;&quot;&quot;Récupère un professeur par email (ou None)&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        c.execute('SELECT * FROM professors WHERE email = ? LIMIT 1', (email,))&#10;        prof = c.fetchone()&#10;        conn.close()&#10;        return prof&#10;&#10;    # === GESTION ÉTUDIANTS ===&#10;    def add_student(self, first_name, last_name, photo_path=None, encoding=None):&#10;        &quot;&quot;&quot;Ajoute un étudiant&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        try:&#10;            # Convertir l'encoding en bytes si fourni&#10;            encoding_blob = pickle.dumps(encoding) if encoding is not None else None&#10;            &#10;            c.execute('''INSERT INTO students (first_name, last_name, photo_path, encoding)&#10;                        VALUES (?, ?, ?, ?)''', &#10;                     (first_name, last_name, photo_path, encoding_blob))&#10;            conn.commit()&#10;            student_id = c.lastrowid&#10;            print(f&quot;✓ Étudiant {first_name} {last_name} ajouté avec ID: {student_id}&quot;)&#10;            return student_id&#10;        except Exception as e:&#10;            print(f&quot;✗ Erreur lors de l'ajout de l'étudiant: {e}&quot;)&#10;            return None&#10;        finally:&#10;            conn.close()&#10;    &#10;    def get_all_students(self):&#10;        &quot;&quot;&quot;Récupère tous les étudiants&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        c.execute('SELECT id, first_name, last_name, photo_path FROM students ORDER BY last_name')&#10;        students = c.fetchall()&#10;        conn.close()&#10;        return students&#10;    &#10;    def get_student_encodings(self):&#10;        &quot;&quot;&quot;Récupère tous les encodages des étudiants&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        c.execute('SELECT id, first_name, last_name, encoding FROM students WHERE encoding IS NOT NULL')&#10;        results = c.fetchall()&#10;        conn.close()&#10;        &#10;        encodings = []&#10;        students_info = []&#10;        &#10;        for student_id, first_name, last_name, encoding_blob in results:&#10;            if encoding_blob:&#10;                encoding = pickle.loads(encoding_blob)&#10;                encodings.append(encoding)&#10;                students_info.append({&#10;                    'id': student_id,&#10;                    'name': f&quot;{first_name} {last_name}&quot;,&#10;                    'first_name': first_name,&#10;                    'last_name': last_name&#10;                })&#10;        &#10;        return encodings, students_info&#10;    &#10;    # === GESTION SÉANCES ===&#10;    def create_session(self, professor_id, subject, session_date=None):&#10;        &quot;&quot;&quot;Crée une nouvelle séance&quot;&quot;&quot;&#10;        if session_date is None:&#10;            session_date = datetime.now().strftime('%Y-%m-%d')&#10;        &#10;        start_time = datetime.now().strftime('%H:%M:%S')&#10;        &#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        try:&#10;            c.execute('''INSERT INTO sessions (professor_id, subject, session_date, start_time)&#10;                        VALUES (?, ?, ?, ?)''', &#10;                     (professor_id, subject, session_date, start_time))&#10;            conn.commit()&#10;            session_id = c.lastrowid&#10;            print(f&quot;✓ Séance créée avec ID: {session_id}&quot;)&#10;            return session_id&#10;        except Exception as e:&#10;            print(f&quot;✗ Erreur lors de la création de la séance: {e}&quot;)&#10;            return None&#10;        finally:&#10;            conn.close()&#10;    &#10;    def end_session(self, session_id):&#10;        &quot;&quot;&quot;Termine une séance&quot;&quot;&quot;&#10;        end_time = datetime.now().strftime('%H:%M:%S')&#10;        &#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        try:&#10;            c.execute('UPDATE sessions SET end_time = ? WHERE id = ?', &#10;                     (end_time, session_id))&#10;            conn.commit()&#10;            print(f&quot;✓ Séance {session_id} terminée à {end_time}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;✗ Erreur lors de la fin de la séance: {e}&quot;)&#10;        finally:&#10;            conn.close()&#10;    &#10;    # === GESTION PRÉSENCES ===&#10;    def mark_attendance(self, session_id, student_id):&#10;        &quot;&quot;&quot;Marque la présence d'un étudiant&quot;&quot;&quot;&#10;        check_in_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')&#10;        &#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        try:&#10;            c.execute('''INSERT OR IGNORE INTO attendance (session_id, student_id, check_in_time)&#10;                        VALUES (?, ?, ?)''', &#10;                     (session_id, student_id, check_in_time))&#10;            conn.commit()&#10;            &#10;            if c.rowcount &gt; 0:&#10;                print(f&quot;✓ Présence marquée pour l'étudiant ID: {student_id}&quot;)&#10;                return True&#10;            else:&#10;                print(f&quot;⚠ Présence déjà marquée pour l'étudiant ID: {student_id}&quot;)&#10;                return False&#10;        except Exception as e:&#10;            print(f&quot;✗ Erreur lors du marquage de présence: {e}&quot;)&#10;            return False&#10;        finally:&#10;            conn.close()&#10;    &#10;    def export_attendance_to_csv(self, session_id, filename='attendance_report.csv'):&#10;        &quot;&quot;&quot;Export les présences d'une séance en CSV&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        &#10;        c.execute('''&#10;            SELECT &#10;                s.first_name || ' ' || s.last_name as student_name,&#10;                a.check_in_time,&#10;                a.status&#10;            FROM attendance a&#10;            JOIN students s ON a.student_id = s.id&#10;            WHERE a.session_id = ?&#10;            ORDER BY a.check_in_time&#10;        ''', (session_id,))&#10;        &#10;        results = c.fetchall()&#10;        conn.close()&#10;        &#10;        with open(filename, 'w', encoding='utf-8') as f:&#10;            f.write('Nom Complet,Heure d\'arrivée,Statut\n')&#10;            for row in results:&#10;                f.write(f'{row[0]},{row[1]},{row[2]}\n')&#10;        &#10;        print(f&quot;✓ Rapport exporté vers {filename}&quot;)&#10;        return filename&#10;    &#10;    def get_session_stats(self, session_id):&#10;        &quot;&quot;&quot;Obtient les statistiques d'une séance&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        &#10;        # Total étudiants&#10;        c.execute('SELECT COUNT(*) FROM students')&#10;        total_students = c.fetchone()[0]&#10;        &#10;        # Présents&#10;        c.execute('SELECT COUNT(*) FROM attendance WHERE session_id = ?', (session_id,))&#10;        present_count = c.fetchone()[0]&#10;        &#10;        conn.close()&#10;        &#10;        return {&#10;            'total': total_students,&#10;            'present': present_count,&#10;            'absent': total_students - present_count,&#10;            'percentage': (present_count / total_students * 100) if total_students &gt; 0 else 0&#10;        }" />
              <option name="updatedContent" value="import sqlite3&#10;from datetime import datetime&#10;import pickle&#10;&#10;class AttendanceDatabase:&#10;    def __init__(self, db_name='attendance_system.db'):&#10;        self.db_name = db_name&#10;        self.init_database()&#10;    &#10;    def init_database(self):&#10;        &quot;&quot;&quot;Initialise la base de données avec les tables nécessaires&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        &#10;        # Table des professeurs&#10;        c.execute('''CREATE TABLE IF NOT EXISTS professors (&#10;            id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;            first_name TEXT NOT NULL,&#10;            last_name TEXT NOT NULL,&#10;            subject TEXT NOT NULL,&#10;            email TEXT NOT NULL UNIQUE,&#10;            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;        )''')&#10;        &#10;        # Table des étudiants&#10;        c.execute('''CREATE TABLE IF NOT EXISTS students (&#10;            id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;            first_name TEXT NOT NULL,&#10;            last_name TEXT NOT NULL,&#10;            photo_path TEXT,&#10;            encoding BLOB,&#10;            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;        )''')&#10;        &#10;        # Table des séances&#10;        c.execute('''CREATE TABLE IF NOT EXISTS sessions (&#10;            id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;            professor_id INTEGER,&#10;            subject TEXT,&#10;            session_date DATE,&#10;            start_time TIME,&#10;            end_time TIME,&#10;            FOREIGN KEY (professor_id) REFERENCES professors(id)&#10;        )''')&#10;        &#10;        # Table des présences&#10;        c.execute('''CREATE TABLE IF NOT EXISTS attendance (&#10;            id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;            session_id INTEGER,&#10;            student_id INTEGER,&#10;            check_in_time TIMESTAMP,&#10;            status TEXT DEFAULT 'present',&#10;            FOREIGN KEY (session_id) REFERENCES sessions(id),&#10;            FOREIGN KEY (student_id) REFERENCES students(id),&#10;            UNIQUE(session_id, student_id)&#10;        )''')&#10;        &#10;        # Assurer l'existence de la colonne email et d'un index UNIQUE (migration pour bases existantes)&#10;        c.execute(&quot;PRAGMA table_info('professors')&quot;)&#10;        cols = [row[1] for row in c.fetchall()]&#10;        if 'email' not in cols:&#10;            try:&#10;                c.execute(&quot;ALTER TABLE professors ADD COLUMN email TEXT&quot;)&#10;                conn.commit()&#10;                print(&quot;→ Colonne 'email' ajoutée à la table professors (migration)&quot;)&#10;            except Exception as e:&#10;                print(f&quot;⚠ Impossible d'ajouter la colonne 'email': {e}&quot;)&#10;        # Créer un index UNIQUE si non présent (permet d'imposer l'unicité sur les valeurs non-null)&#10;        try:&#10;            c.execute(&quot;CREATE UNIQUE INDEX IF NOT EXISTS idx_professors_email ON professors(email);&quot;)&#10;            conn.commit()&#10;        except Exception as e:&#10;            print(f&quot;⚠ Impossible de créer l'index unique sur email: {e}&quot;)&#10;        &#10;        conn.close()&#10;        print(&quot;✓ Base de données initialisée avec succès&quot;)&#10;    &#10;    # === GESTION PROFESSEURS ===&#10;    def add_professor(self, first_name, last_name, subject, email):&#10;        &quot;&quot;&quot;Ajoute un professeur&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        try:&#10;            c.execute('''INSERT INTO professors (first_name, last_name, subject, email)&#10;                        VALUES (?, ?, ?, ?)''', (first_name, last_name, subject, email))&#10;            conn.commit()&#10;            professor_id = c.lastrowid&#10;            print(f&quot;✓ Professeur {first_name} {last_name} ajouté avec ID: {professor_id}&quot;)&#10;            return professor_id&#10;        except sqlite3.IntegrityError as ie:&#10;            # Erreur d'unicité (email déjà existant)&#10;            print(f&quot;✗ Intégrité DB lors de l'ajout du professeur (possible email dupliqué): {ie}&quot;)&#10;            return None&#10;        except Exception as e:&#10;            print(f&quot;✗ Erreur lors de l'ajout du professeur: {e}&quot;)&#10;            return None&#10;        finally:&#10;            conn.close()&#10;    &#10;    def get_all_professors(self):&#10;        &quot;&quot;&quot;Récupère tous les professeurs&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        c.execute('SELECT * FROM professors ORDER BY last_name')&#10;        professors = c.fetchall()&#10;        conn.close()&#10;        return professors&#10;&#10;    def get_professor_by_email(self, email):&#10;        &quot;&quot;&quot;Récupère un professeur par email (ou None)&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        c.execute('SELECT * FROM professors WHERE email = ? LIMIT 1', (email,))&#10;        prof = c.fetchone()&#10;        conn.close()&#10;        return prof&#10;&#10;    # === GESTION ÉTUDIANTS ===&#10;    def add_student(self, first_name, last_name, photo_path=None, encoding=None):&#10;        &quot;&quot;&quot;Ajoute un étudiant&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        try:&#10;            # Convertir l'encoding en bytes si fourni&#10;            encoding_blob = pickle.dumps(encoding) if encoding is not None else None&#10;            &#10;            c.execute('''INSERT INTO students (first_name, last_name, photo_path, encoding)&#10;                        VALUES (?, ?, ?, ?)''', &#10;                     (first_name, last_name, photo_path, encoding_blob))&#10;            conn.commit()&#10;            student_id = c.lastrowid&#10;            print(f&quot;✓ Étudiant {first_name} {last_name} ajouté avec ID: {student_id}&quot;)&#10;            return student_id&#10;        except Exception as e:&#10;            print(f&quot;✗ Erreur lors de l'ajout de l'étudiant: {e}&quot;)&#10;            return None&#10;        finally:&#10;            conn.close()&#10;    &#10;    def get_all_students(self):&#10;        &quot;&quot;&quot;Récupère tous les étudiants&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        c.execute('SELECT id, first_name, last_name, photo_path FROM students ORDER BY last_name')&#10;        students = c.fetchall()&#10;        conn.close()&#10;        return students&#10;    &#10;    def get_student_encodings(self):&#10;        &quot;&quot;&quot;Récupère tous les encodages des étudiants&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        c.execute('SELECT id, first_name, last_name, encoding FROM students WHERE encoding IS NOT NULL')&#10;        results = c.fetchall()&#10;        conn.close()&#10;        &#10;        encodings = []&#10;        students_info = []&#10;        &#10;        for student_id, first_name, last_name, encoding_blob in results:&#10;            if encoding_blob:&#10;                encoding = pickle.loads(encoding_blob)&#10;                encodings.append(encoding)&#10;                students_info.append({&#10;                    'id': student_id,&#10;                    'name': f&quot;{first_name} {last_name}&quot;,&#10;                    'first_name': first_name,&#10;                    'last_name': last_name&#10;                })&#10;        &#10;        return encodings, students_info&#10;    &#10;    # === GESTION SÉANCES ===&#10;    def create_session(self, professor_id, subject, session_date=None):&#10;        &quot;&quot;&quot;Crée une nouvelle séance&quot;&quot;&quot;&#10;        if session_date is None:&#10;            session_date = datetime.now().strftime('%Y-%m-%d')&#10;        &#10;        start_time = datetime.now().strftime('%H:%M:%S')&#10;        &#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        try:&#10;            c.execute('''INSERT INTO sessions (professor_id, subject, session_date, start_time)&#10;                        VALUES (?, ?, ?, ?)''', &#10;                     (professor_id, subject, session_date, start_time))&#10;            conn.commit()&#10;            session_id = c.lastrowid&#10;            print(f&quot;✓ Séance créée avec ID: {session_id}&quot;)&#10;            return session_id&#10;        except Exception as e:&#10;            print(f&quot;✗ Erreur lors de la création de la séance: {e}&quot;)&#10;            return None&#10;        finally:&#10;            conn.close()&#10;    &#10;    def end_session(self, session_id):&#10;        &quot;&quot;&quot;Termine une séance&quot;&quot;&quot;&#10;        end_time = datetime.now().strftime('%H:%M:%S')&#10;        &#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        try:&#10;            c.execute('UPDATE sessions SET end_time = ? WHERE id = ?', &#10;                     (end_time, session_id))&#10;            conn.commit()&#10;            print(f&quot;✓ Séance {session_id} terminée à {end_time}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;✗ Erreur lors de la fin de la séance: {e}&quot;)&#10;        finally:&#10;            conn.close()&#10;    &#10;    # === GESTION PRÉSENCES ===&#10;    def mark_attendance(self, session_id, student_id):&#10;        &quot;&quot;&quot;Marque la présence d'un étudiant&quot;&quot;&quot;&#10;        check_in_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')&#10;        &#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        try:&#10;            c.execute('''INSERT OR IGNORE INTO attendance (session_id, student_id, check_in_time)&#10;                        VALUES (?, ?, ?)''', &#10;                     (session_id, student_id, check_in_time))&#10;            conn.commit()&#10;            &#10;            if c.rowcount &gt; 0:&#10;                print(f&quot;✓ Présence marquée pour l'étudiant ID: {student_id}&quot;)&#10;                return True&#10;            else:&#10;                print(f&quot;⚠ Présence déjà marquée pour l'étudiant ID: {student_id}&quot;)&#10;                return False&#10;        except Exception as e:&#10;            print(f&quot;✗ Erreur lors du marquage de présence: {e}&quot;)&#10;            return False&#10;        finally:&#10;            conn.close()&#10;    &#10;    def export_attendance_to_csv(self, session_id, filename='attendance_report.csv'):&#10;        &quot;&quot;&quot;Export les présences d'une séance en CSV&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        &#10;        c.execute('''&#10;            SELECT &#10;                s.first_name || ' ' || s.last_name as student_name,&#10;                a.check_in_time,&#10;                a.status&#10;            FROM attendance a&#10;            JOIN students s ON a.student_id = s.id&#10;            WHERE a.session_id = ?&#10;            ORDER BY a.check_in_time&#10;        ''', (session_id,))&#10;        &#10;        results = c.fetchall()&#10;        conn.close()&#10;        &#10;        with open(filename, 'w', encoding='utf-8') as f:&#10;            f.write('Nom Complet,Heure d\'arrivée,Statut\n')&#10;            for row in results:&#10;                f.write(f'{row[0]},{row[1]},{row[2]}\n')&#10;        &#10;        print(f&quot;✓ Rapport exporté vers {filename}&quot;)&#10;        return filename&#10;    &#10;    def get_session_stats(self, session_id):&#10;        &quot;&quot;&quot;Obtient les statistiques d'une séance&quot;&quot;&quot;&#10;        conn = sqlite3.connect(self.db_name)&#10;        c = conn.cursor()&#10;        &#10;        # Total étudiants&#10;        c.execute('SELECT COUNT(*) FROM students')&#10;        total_students = c.fetchone()[0]&#10;        &#10;        # Présents&#10;        c.execute('SELECT COUNT(*) FROM attendance WHERE session_id = ?', (session_id,))&#10;        present_count = c.fetchone()[0]&#10;        &#10;        conn.close()&#10;        &#10;        return {&#10;            'total': total_students,&#10;            'present': present_count,&#10;            'absent': total_students - present_count,&#10;            'percentage': (present_count / total_students * 100) if total_students &gt; 0 else 0&#10;        }" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>